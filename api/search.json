[{"id":"8a52b678b373829720d5a0fbb61a4c60","title":"qm Java note","content":"JAVA NOTE\n大二下学期qm Java的笔记（略有补充），仅供参考\n\n[TOC]\nTeaching Block11.phase of java programphase1: Edit(by editor ):  Every java program have the extensing .java\nphase2: Compile(编译器): \n\n\n\n\n\n\n\n\n\ntranslates your program into bytecode so that the Java interpreter can read the   program（MyProgram.class）                     \njavac Myprogram.java\n\nPhase 3: Load + Phase 4: Verify\n\n\n\n\n\n\n\n\n\nloading into memory\njava MyProgram\n\nPhase 5: Execute\nThe file name and the class name must be the same. \nMyProgram.java\n\nTo compile the program, type (with file extension编译时加后缀):\njavac MyProgram.java\n\nTo run the program, type (without file extension运行不加后缀):\njava MyProgram\n\nThe interpreter executes main first.\nJVM包括：\njavac: compiler\njava: launcher for Java applications\njavadoc: API documentation generator\njar: manages JAR files\njdb: Java debugger\n1.1.补充1.常见dos命令\n1.2.补充2.main method\n2.Basic data types（基本数据类型、引用数据类型）2.1.introduction\n\n\n\n\n\n\n\n\n   Java is strongly typed and strongly classed– Only variables with the same types or classes can be used together.\n\nEvery data type in Java has a default value\n\n\n\n\n\n\n\n\n\n\nlong类型在数字后面加L否则整数默认为int类型\n\n\n\n\n\n\n\n\n\nfloat 加F 否则小数默认为 double类型\n2.2.补充1.变量命名规则\n\n2.3.补充2.类型转换 自动类型转换：范围小的数赋值给范围大的数\n强制类型转化(type cast operator.) ：范围大的数赋值给范围小的数\nint k=(int)88.8\n\n  Conversion between numeric types:\n\n\n\n\n\n\n\n\n\nbyte &#x3D;&gt; short &#x3D;&gt; int &#x3D;&gt; long &#x3D;&gt; float &#x3D;&gt; double\n​                                         \n3.Operators3.1.introduction\nIncrements and Decrements\n\n\n\n\n\n\n\n\n\n\n\n– A post operation causes the variable to first be used  in the current statement, and then it is incremented or decremented afterwards.\n\n\n\n\n\n\n\n\n\n– A pre operation causes the variable to first be incremented or decremented, and then it is used in the current statement.\nPost incrementing\n\nint a = 4;\nint result = a++ + a;\nSystem.out.println(\"result = \" + result + \", a = \" + a ); \nOUTPUT:\nresult=9 a=5\n\na = 4;\nresult = a + a++;\nSystem.out.println(\"result = \" + result + \", a = \" + a );\nOUTPUT:\nresult=8 a=5\n\nPre incrementing\n\nint a = 4;\nint result = ++a + a;\nSystem.out.println(\"result = \" + result + \", a = \" + a ); \nOUTPUT:\nresult=10 a=5\n\na = 4;\nresult = a + ++a;\nSystem.out.println(\"result = \" + result + \", a = \" + a ); \nOUTPUT:\nresult=9 a=5\n\n\n\n\n\nOperator Precedence(优先级)\n\n\n\nRelational Operations\n\n\n\nLogical operators\n\n\n\n– binary operators (except assignment) are evaluated from left to right\n– assignment operators are evaluated right to left\nint a = 4;\nint b = 1;\nint c = 3;\nint result = a = b = c;\na/b/c都为3\n\n\nif-else statement\nRelational expression must evaluate to a boolean value\n\n\nswitch statement\n\n\n\n\n\n\n\n\n\n\n\nbreak – causes the remainder of the **switch **statement to be skipped\n\n\n\n\n\n\n\n\n\ndefault – action in case none of the cases match\n\nConditional Operator\n\n\n\n\nThe break and continue statements\n\n​         break——quitting the loop\n​         continue——skipping the current iteration\n​      补充:Using labelled statement blocks with break and continue\nouter:\n    for (int i=1; i&lt;5; i++) &#123;\n      System.out.println(\"Begin outer for i=\" + i); \ninner:\n      for (int j=1; j&lt;5; j++) &#123;\n        if (j == i) break outer;\n      &#125;\n      &#125;\n\nouter:\n   for (int i=1; i&lt;5; i++) &#123;\n     System.out.println(\"Begin outer for i=\" + i); \ninner:\n     for (int j=1; j&lt;5; j++) &#123;\n       if (j == i) continue;\n  System.out.println(\"   inner: i=\" + i + \" j=\" + j);\n     &#125;\n     System.out.println(\"End outer for i=\" + i); \n   &#125; \n\n3.2.IDEA使用\n项目结构：模块-包-java类\n\n\n\n快捷键\n\n\n\n4. OO programming and objects4.1.introduction\nWhat is OO programming?\n\n\n\n\n\n\n\n\n\n\nConstructing software systems which are structured collections(or sets) of classes.\nThese classes produce instances called objects\n\nWhat is object?Objects are things or nouns.\n\nAttributes (or states) of an object:\n\n\n\n\n\n\n\n\nessentially anything that describes or quantifies an object. \n\nOperations (or behaviours) of an object:\n\n\n\n\n\n\n\n\nthey mostly correspond to verbs in a requirements specification.\n\n\n The class defines the attributes and operations exposed by one or more related objects\n\nWhat is a class?\n\n​     An object is an instance of a particular class, We can split up code between different objects.\n\nUMLClass diagram notation\nUML &#x3D; Unified Modelling Language\n\n\n\n4.2.Methods\n\nsyntax\n\nmodifiers returnType methodName(parameters) &#123;\nstatements;\n&#125;\n\n\nA method uses parameters&#x3D;形参(formal parameter), whereas the caller passes arguments&#x3D;实参(actual parameter).\n\nCalling(调用) a method\n\n\n\n\n\nPass-by-value（Pass-by-copy）\n\n\n\n\n\n\n\n\n在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。\n\nMethod OverloadingJava allows several methods to be defined with the same name, as long as they have different sets of parameters\n&#x3D;&#x3D;The return type is NOT used to differentiate methods&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n\n\n\n只有参数类型有关,与返回值类型无关               \n4.3.Create a class\n\n\n\n\n\n\n\n\ninstance variable(成员变量)+instance method（成员方法）+constructors（构造方法）\nattribute——instance variable    ， operation——instance method\n\nclass XXX&#123;\n  int attribute1=1;\n  double attribute2=2;\n  //instance variable\n   XXX(int xxx)&#123;   \n    &#125;\n   //constructors\n    \n    double opeartion1()&#123;   \n    &#125;\n    int opeartion2()&#123;  \n    &#125;\n   //instance method\n&#125;\n\n\ncreate a object\n\nclassName objectName=new className();\n\n\n\n\n\n\n\n\n\n\nA  object is a reference variable. \n\nUsing instance variables and methods\n\n– to access a (public) instance variable v of an object o, we reference it using the dot notation*:*\no.v\n\n– to invoke a (public) method m of an object o, we also reference it using the dot notation:\no.m()\n\n\nConstructorsA constructor is a special method, with same name as the class name, used for initialisation.\n\n\n\n\n\n\n\n\n\n\nIt does not have a return type, not even void!\n An empty no-argument constructor is provided for you by Java(如果没有自定义，系统会自带一个无参构造方法，如果自己写了构造方法，系统将不提供无参构造方法)。\n\npublic Cat() &#123;\n\n&#125;\n\n\nData Encapsulation(对成员变量封装)\n\nThis is a good thing! Since objects are only accessible through well defined interfaces, ideally nothing unexpected should happen!\n\n\n\n\n\n\n\n\n\nWe should NOT allow direct access to an object’s variables.\n\n\n\n\n\n\n\n\n\nAny changes to the object’s state (i.e. its variables) should be made ONLY by that object’s methods\n把成员变量定义加private，并且添加两个method实现访问和更改变量\naccessor(访问器)：get方法——getXxx()\nmutator(修改器)：set方法——setXxx()\nAll getters and setters should have names that conform to the following:\n&#x3D;&#x3D;variableType getVariableName()&#x3D;&#x3D; \n&#x3D;&#x3D;void setVariableName(VariableType)&#x3D;&#x3D;\npublic void setAge(int age)&#123;\n       this.age=age;\n   &#125;\n \npublic int getAge()&#123;\n       return age;\n   &#125;\n\n\nthis引用this 是指向对象本身的引用名，利用this引用对象的instance variable\n\npublic void setAge(int age)&#123;\n      this.age=age;\n  &#125;\n\n\n\n\n\n\n\n\n\n\n不加this指代parameters, 加this指代instance variable\n补充：this（）可以用来同类的另一个构造方法\nPerson(String nm) &#123;\n        name &#x3D; nm;\n    &#125;\nPerson(String nm, int a) &#123;\n        this(nm);\n        age &#x3D; a;\n    &#125;\n\n\n\ntoString() methodThis method returns a String representation of the object.\npublic String toString() &#123;\nreturn “Account number: ” + accNo + “\\n” \n+ “Account name: ” + accName + “\\n”\n+ “Balance: ” + balance ;\n&#125;\n\n它通常只是为了方便输出,在main中需要输出class的变量时，直接使用：\nSystem.out.println(classname);\n\n等同于\nSystem.out.println(classname.toString);\n\n4.4.Method parameters 、 local variables、instance variables\n\n\n\n\n\n\n\n\nMethod parameters are virtually the same as local variables!\n– They are declared inside the method.\n– They are valid (or in scope) only inside the method.\n– They are NOT initialised to the default value, and so must be initialised(by the caller of the method).必须初始化\n\nInitialisation（变量初始化）Java automatically sets some initial values for you for variables of the class (instance variables), but not for variables in methods（local variable）\n\n\nclass variable 也会自动初始化\nTeaching Block21.ArraysArrays provide fast random access by letting you use an index position to get any element in the array.\n\n\n\n\n\n\n\n\n\nArrays must be given a size! \nStandard arrays cannot grow and shrink in size\n\n\n静态初始化：\nint[] arr&#x3D;&#123;1,2,3&#125;;\n\n动态初始化：\n只指定数组的长度\n\n\nAn array is an object, even though it may be an array of primitives.\n\nArray elements can be either primitives or objects.\n\nThe main() method has the Array of Strings.\n\n\npublic static void main(String[] args) \n\n数组的长度：array.length(是一个整形)\n如果length&#x3D;3 （length&#x2F;2&#x3D;1）注意在for循环里出现！\n动态初始化一个对象数组时，new后面是类名（只是表示这个reference variable什么类型）并不是构造方法。\n1.1.copy arrayreference copy: Only copies the reference value!\nRabbit[] racers2;\n\nracers2 = racers;\n\ncopy the data type variables:\n\nUse a loop to copy all individual elements.\n\nUse the static arraycopy method in the System class\n\n\n\nsrc is the array to copy from; dest is the array to copy to\n• srcPos is where in the src array to start copying from.\n• destPos is where, in the dest array, to start putting the newly copied \nelements\n1.2.Passing Arrays to MethodsJava uses pass-by-value, to pass arguments to a method(only have pass by value)\n\n\n\n\n\n\n\n\n\nJava passes (to the method) a copy of the reference variable to the array object \n数组作为方法参数—传递地址\n1.3.“Prep code”\n\n\n\n\n\n\n\n\nA form of pseudocode, to help focus on the logic without the worry of syntax\n2.Stringjava 中的所有双引号中都为字符串。\n不是基本的数据类型。\n\nstring 特点：\n\n\n\n\n\n\n\n\n\nString对象不可变 Strings are immutable\n但是如下代码是可以执行的（因为“java”创建的是对象，“java”内容不能改变，但是下方代码意思是s这个引用类型的变量指向新的对象“html”）\n\n\nString s=\"java\";\ns=\"html\";\n\n不能改变s的值\nString Pool: Area of memory where String literals are put by the JVM when created\n\n\n\n\n\n\n\n\n\nGarbage Collector doesn’t cleanup the String Pool!\nJVM doesn’t create a duplicate if there’s already a String in memory with \nthe same value; it refers the reference variable to the existing entry\nJVM不会创建相同值的string，只会使引用变量指向这个字符串\n\nstring构造方法：\n\n\n两种创建字符串的方法以及内存分析：\n通过new创建对象，每次都会申请一个新的内存空间。\n以”“创建对象如果内容一样，则jvm只会创建一个String对象\nString st1=new String(ch2);\n       String st2=new String(ch2);\n       System.out.println(st1==st2);\n   //new构建时，st1与st2地址不同\n  \n       String st3=\"abc\";\n       String st4=\"abc\";\n       System .out .println(st3==st4);\n       //直接赋值时，st3与st4的地址相同\n\n\n&#96;&#96;&#96;java&#x2F;&#x2F;运行结果为true falseString s1 &#x3D; “AB”;String s2 &#x3D; “AB”;String s3 &#x3D; new String(“AB”); System.out.println(s1 &#x3D;&#x3D; s2); System.out.println(s1 &#x3D;&#x3D; s3);\n    由于常量池中不存在两个相同的对象，所以s1和s2都是指向JVM字符串常量池中的&quot;AB&quot;对象。new关键字一定会产生一个对象，并且这个对象存储在堆中。所以String s3 &#x3D; new String(“AB”);产生了两个对象：保存在栈中的s3和保存堆中的String对象。\n\n   ![java1&#x2F;image-20220602155952465](java1&#x2F;image-20220602155952465.png)\n\n   这是因为通过构造方法（new）创建字符串对象时，该对象位于heap上\n\n    而使用“”创建时，该字符串位于String Pool(通过＋组合时也是如此)\n\n   ![java1&#x2F;image-20220602160005972](java1&#x2F;image-20220602160005972.png)\n\n   &gt; GC不会清理String pool，但是可以清理new出的在堆中的string\n\n**Methods:** **String** **Class**\n\n- 字符串的比较\n\n![java1&#x2F;image-20220331213600524](java1&#x2F;image-20220331213600524-1653819852852.png)\n\n&#96;&#96;&#96;java\nstring1.equals(string2)\n\n\n字符串相加：\nJava overloads the + operator for string concatenations.\n\n\nSystem.out.println(\"aaa\"+1+1);输出 aaa11\n\n System.out.println(\"aaa\"+(1+1));输出 aaa2\n\n\n字符串转字符\n\n\n\n字符串长度\n\n\nchar charAt(int index): returns the character at index\n\nint indexOf(ch): returns ch’s first occurrence position; if not found returns -1.\n\n\nint compareTo(str): compares two strings, returns &lt; ,&gt; , &#x3D;0 if the compared string is smaller, larger, or equal to str. \n\nsubstring(index1,index2): returns the substring between index1and (excluding) index2.\n\nconcat(s): concatenates（连接） two strings.\n\ntoUpperCase() &#x2F; toLowerCase(): convert all characters in string to upper&#x2F;lower case\n\ntoString(): convert input to a string.\n\ndouble d = 12.3;\nString dString = Double.toString(d); // dString = “12.3”\n\n- **void getChars(i,j,A,k)**: returns characters from **i** to **j** (excluding), and stores them into array* **A** starting from **A[k]**.\n\n- &#96;&#96;&#96;java\n  char[] A &#x3D; new char[4];\n  “The rain in Spain”.getChars(4,8,A,0);\n  &#x2F;&#x2F; A &#x3D; &#123;’r’,’a’,’i’,’n’&#125;\n\n **substring(index)**: returns substring from **index** to end.\n\nString s = “Monkeys”.substring(3); // s = “keys”\nString s = “Monkeys”.substring(3,”Monkeys”.length()-1); \n\n// s = “key”\n\nreplace(oldCh,newCh)**: replace **oldCh by **newCh** everywhere in the string.\n\nString s = “goose”.replace(‘o’,‘e’); //s = “geese”\n\n\nsplit(String s): splits the string around matches of the given regular expression s and returns an array with those substrings\npublic class UsingSplit &#123;\npublic static void main(String[] args) &#123;\nString str = \"bar:foo:bar\";\nString[] splitStr = str.split(\":\");\nfor (int i=0; i &lt; splitStr.length; i++)\nSystem.out.println(splitStr[i];\n&#125; &#125;\n\nOUTPUT:\nbar\nfoo\nbar\n\nvoid getChars(i,j,A,k): returns characters from i to j (excluding), and stores them into array A starting from A[k]\n\nsubstring(index): returns substring from index to end.\n\nreplace(oldCh,newCh): replace oldCh by newCh everywhere in the \nstring\n\n\n\n\n Format Specifier\nThe following table shows the format specifiers:\nformat() 函数与数字，字符结合使用:\n^ 、 &lt; 、 &gt; 分别是居中、左对齐、右对齐，后面带宽度\n: 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。\n+ 表示数学中的正负号，在正数前显示+，负数前显示-； （空格）表示在正数前加空格\nb、d、o、x 分别是二进制、十进制、八进制、十六进制。\n\n\n\n\nFormat Specifier\nConversion Applied\n\n\n\n%a %A\nFloating-point hexadecimal\n\n\n%b %B\nBoolean\n\n\n%c\nCharacter\n\n\n%d\nDecimal integer\n\n\n%h %H\nHash code of the argument\n\n\n%e %E\nScientific notation\n\n\n%f\nDecimal floating-point\n\n\n%g %G\nUses %e or %f, whichever is shorter\n\n\n%o\nOctal integer\n\n\n%n\nInserts a newline character\n\n\n%s %S\nString\n\n\n%t %T\nTime and date\n\n\n%x %X\nInteger hexadecimal\n\n\n%%\nInserts a % sign\n\n\nformat() 函数与参数结合使用\n格式化字段将会被 format() 中的参数替换\nprint(\"我叫&#123;&#125;,今年&#123;&#125;!\".format(\"张三\",22))\nprint(\"我叫&#123;0&#125;,今年&#123;1&#125;!\".format(\"张三\",22))\nprint(\"我叫&#123;1&#125;,今年&#123;0&#125;!\".format(\"张三\",22))\n我叫张三,今年22!\n我叫张三,今年22!\n我叫22,今年张三!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStringTokenizer ClassThe StringTokenizer class is used to extract tokens and process text from a string, and it belongs to the java.util package.\nStringTokenizer is a legacy class; should not be used with new code,用 String.split()\n3.StringBuilder\n\n\n\n\n\n\n\n\n可变字符串\n\n构造方法\n\n\n\n添加和反转\n\n\n返回值是本身的类，所以可以链式编程\n\n与String的转换\n\n\n4.ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。\nArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下：\nimport java.util.ArrayList; // 引入 ArrayList 类\n\nArrayList&lt;E> objectName =new ArrayList&lt;E>();　 // 初始化\n\n\n\n\n\n\n\n\n\n\nE: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。\n4.1.Some ArrayList methods常用的method：\n\n\n Find out if it contains something:\nboolean inIt = myList.contains(f);\n\nFind out where in the list something is:\nint index = myList.indexOf(f);\n\nFind out if the list is empty:\nboolean empty = myList.isEmpty();\n\nArrayList字符串遍历的基本格式：\n\n5.Inheritance and Abstract classes5.1.two primary types of relationships between classes– aggregation (referred as has-a)\n– inheritance (referred as is-a)\n5.2.Inheritance\n\n\n\n\n\n\n\n\nvia the extends keyword\n\n Subclasses inherit the properties (attributes and operations(方法和成员变量)) of their superclass.\n\nTo provide specialisations, subclasses &#x3D;&#x3D;override&#x3D;&#x3D; methods that they inherit from the superclass\n父类的私有数据域在子类中仍是不能访问的。java中只支持单一继承。\n构造方法不会被继承\nAccess Modifiers（可访问修饰符）\n\n\npublic\n\n– public instance variables and methods are inherited\n• protected\n– protected instance variables and methods are inherited\n• private\n– any private instance variables and methods\nare not inherited and cannot be seen by the subclass\ndefault: 不加任何修饰符\n方法、变量四种都可以加\n\n\n\n\n\n\n\n\n\n普通类（外部类）：只能用public、default（不写）、abstract、final修饰。\n\n\n\n\n\n\n\n\n\n（成员）内部类：可理解为外部类的成员，所以修饰类成员的public、protected、default、private、static等关键字都能使用。\n5.2.1.override要与父类方法声明一模一样\n\n方法重写时建议加注解@Override以区分是否为重写还是新子类方法\n\n\n5.2.2.super的使用Every object holds both its own declared instance variables and everything from its superclasses.\nsuper用于指代父类，可以调用父类中的普通方法和构造方法\n调用普通方法类似于this的语法：super.方法名（参数）；\n调用父类的构造方法\n\n每个子类构造方法执行的&#x3D;&#x3D;第一步&#x3D;&#x3D;都为隐式调用（先访问父类的无参构造方法）所以每个父类一定要重载无参构造方法。if no constructor is provided, the compiler adds one that looks like:\npublic ClassName() &#123; super(); &#125;\n\nthis指本类，super指代父类。\n\n5.2.3.成员方法访问的特点\n\n5.2.4.final和static关键字\nfinal可以修饰方法、变量、类\n\n\n Using this keyword will prevent child classes   (oranyone else) modifying the variable&#x2F;method this applies to\nfinal修饰的变量必须初始化（常量），不能被改变。\n在使用final修饰基本类型变量的时候，不可以对基本类型变量重新赋值，所以的话，基本类型变量不能被改变，可是对于引用类型变量来说的话，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，也就是一直引用同一个对象，但这个对象完全可以发生改变。\n如果final修饰数组那么数组的内容可以改变，但是不能重新为这个reference variable分配新数组对象了\nfinal variables must either be initialised when declared or in the constructor\n\npublic static int a;\n\n任意一个对象给a赋值之后所有对象共享a的值。\nAll instances of the same class share one copy of an static variable.\n\n\n\n\n\n\n\n\n\nInitialisation of static variables happens before any object of the class \nis created\n一般对static修饰的变量访问时使用\n类名.变量名&#x3D;xxxx;\n类名.方法名（）\n使用类名对此变量统一赋值。\nstatic修饰方法：（静态方法可以被继承，不能被重写）\n\nStatic Imports(调用方法时不用写类名了)\nimport static java.lang.System.out;\n\nimport static java.lang.Math.;\n\nclass WithStaticImports &#123;\n\npublic static void main(String [] args) &#123;\n\nout.println(“square root is “ + sqrt(4.0));\n\n&#125; \n\n&#125;\n\n\n\n\n\n修饰符\n修饰变量\n修饰方法\n修饰类\n\n\n\nstatic\n整个类都可以访问，直接用类名访问\n静态方法，不可被重写\n\\\n\n\nfinal\n不可更改（常量）\n不能被重写\n最终类，不可被继承\n\n\n6.polymorphismPolymorphism ：Using a single definition (superclass) with different types (subclass)\n（父类变量指向子类对象）\nCreature c = new Rabbit();\n\n\n\n\n\nobject o=new student();\n\n其中object是o的声明类，student是o的实际类，o调用方法时由实际类型决定。\n访问时要先看左边（声明类）中有无此变量或对象，如果有才可以执行。\n执行方法时执行的是右边（实际类）的重写方法，执行变量时是执行声明类中的变量。\n多态中的对象转换：\n\n向上转型\nobject o&#x3D;new student();\n向下转换（强制）– Explicit cast\nstudent b&#x3D;(student)o;\n6.1.java的object类中常用方法：\n\n\n\n\n\n\n\n\njava.lang.Object is the ultimate parent of EVERY class in java\nSome methods of the “object” class\n\n\n\n\n\n\n\n\n\nequals() determines when one object is equal to another\n未重写：判断两类的地址是否相同\n在类中重写equals()判断两个类内容是否相等。\n\n\n\n\n\n\n\n\n\ntoString() allows objects to be printed\n输出：类名@加地址\n重写toString()打印类中信息\n\n\n\n\n\n\n\n\n\nhashCode() is a unique ID for every object, usually based on its memory address\n\n\n\n\n\n\n\n\n\ngetClass() returns the class of the object返回类名\n7.abstract classThe compiler will not let you instantiate an abstract class.\n– The only use it has is in being extended\n A non-abstract class is called a concrete class.\n• abstract in terms of classes  that class must be extended, in \norder to be instantiated\n• abstract for methods   the method must be overridden in the \nchild class\n\n\n\n\n\n\n\n\n\nsubclass must implement ALL abstract methods from its superclass (or be declared abstract).\n\n抽象方法：\npublic abstract void eat();\n\n\n\n8.inner class\nInner (or Nested) Class: Standard class declared within the scope of a standard top-level (or enclosing) class\n\n\n\nAn inner class is defined in the scope of an outer class.\n\n (An instance of) it can reference data and methods (even private ones) of the outer class it belongs to.\n\n\n\n\nAn instance of an inner class (i.e. an inner object) must be associated with a specific outer object on the heap!\n\n\n\n\nAn anonymous class is a special kind of class: a local class without a name.\n\n• only one instance of the class can ever be made;\n• class can’t be accessed from anywhere else in the program\n It allows an object to be created using an expression that combines object creation with the declaration of the class.\nAn anonymous class is defined as part of a new expression and mustbe a subclass or implement an interface.（必须是子类或者接口的实现）\n– The class body can define methods but cannot define any constructors.\n\n匿名内部类，在【创建对象】的时候，只能使⽤唯⼀⼀次。\n如果希望多次创建对象，⽽且类的内容⼀样的话，那么就需要使⽤单独定义的实现类了。\n匿名对象，在【调⽤⽅法】的时候，只能调⽤唯⼀⼀次。\n如果希望同⼀个对象，调⽤多次⽅法，那么必须给对象起个名字。\n匿名内部类是省略了【实现类&#x2F;⼦类名称】，但是匿名对象是省略了【对象名称】\n\n\n\n\n\n\n\n\n\n强调：匿名内部类和匿名对象不是⼀回事！！！\n9.Debugger Compilation or syntactical errors: easiest type of error to debug\n Logic errors: occur during the program’s execution.\n runtime errors &amp; threading errors\nTeaching Block31.interface接口是一种与类类似的结构，只能包含常量和抽象方法。\n无构造方法\n\nBefore Java SE8, interfaces could have:\nstatic final 位置可换！！\n\nconstant fields (public static final可以省略)(引用时使用父类接口作为前缀Father.age)\npublic static final int x = 10;\n\nabstract methods （public abstract可以省略）\npublic abstract void doStuff();\n\n\nFrom Java SE8, interfaces can also have:\n\n\n\n\n\n\n\n\n\n\ndefault methods  Allow developers to add new functionality to interfaces, without impacting any existing classes that are already implementing the interface.用了default关键字修饰方法之后，这个方法是可以有方法体\n&#x3D;&#x3D;Can be overridden in the class that implements the interface.&#x3D;&#x3D;Provide backward compatibility(向后兼容) for existing interfaces.\n\n\n\n\n\n\n\n\n\nstatic methods  Allow developers to define utility methods in the interface也可以具有方法体（不可被重写）与类中加static一样均可用 接口名.方法名 调用\n\n接口中\npublic interface name()&#123;&#125;\n\n类实现：\npublic class className implements interfaceName&#123;&#125;\n\n\n接口不能利用new实例化，所以必须通过类继承接口后，实例化类间接实现接口实例化\n\nJava’s “multiple inheritance” is at interface level only!(可以利用接口实现Java中的多继承)\npublic class className implements A,B&#123;&#125;\n\nOnly interfaces can do multiple inheritance\n\n\n多继承中如果发生两个父类有相同方法：\n\nSame named methods:\nIf they have different parameters, then Child interface has both (this is same as overloading).\n\n\n​    If they differ by only return type, then error.\n​    If the two methods are identical, only keep one.\n\nSame named constants:\nwe keep both constants. To refer to them, use parent interface name as prefix\n\n\n2.Garbage Collection\nTwo main areas of memory in Java:\n\n– (Garbage-collectible) Heap (where objects live);\n– Stack (where local variables and methods, when called, live)\n2.1.四种变量的存储位置：&#x3D;&#x3D;Local (also known as stack) variables (on the Stack)&#x3D;&#x3D; \n• Variables declared in a method and method parameters.\n• Temporary variables, alive only when the method they belong to is on the Stack\n&#x3D;&#x3D;Instance variables (on the Heap)&#x3D;&#x3D;\n• Variables declared in a class (not inside of a method).\n• Live inside the object they belong to\n&#x3D;&#x3D;Object reference (non-primitive） variables:&#x3D;&#x3D;\n– Hold a reference to an object, not the actual object.\n– A local variable that is a reference to an object goes on the Stack (the object it refers to still goes on the Heap).\n&#x3D;&#x3D;类变量和实例变量：&#x3D;&#x3D;\n A class variable is created when the class is created, rather than when an object is created\nTo declare a class variable, use the modifier static.\nIf you declare something as static, it means that all objects have the same copy of that \nvariable&#x2F;method（见block2）\n• Static is like global variables but applies classwide.\n• Static methods become available when the class is loaded (created), not \nwhen you make an instance of it.\n\n\n2.2.Methods and the Stack Method goes on top of the Stack when it is called and stays in the Stack until it’s done \nStack frame(栈帧):\n– What actually is pushed onto the Stack.\n– Contains the state of the method \n(which line of code is executing and values of all local variables).\n每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。\n\n2.3.Object ReferencesObject reference (aka non-primitive) variables:\n– Hold a reference to an object, not the actual object.\n– A local variable that is a reference to an object goes on the Stack (the object it refers to still goes on the Heap).\n\n\n\n\n\n\n\n\n\nreference variable是一个局部变量所以就在stack上，但是其指向的对象在heap上\n2.4.构造函数链 constructor chaining When an object is created, that object will have “layers” of itself representing each superclass.\n拥有父类的层次和自己的层次\n\n\n\n\n\n\n\n\n\n\nWhen a new object is created, all the constructors in its inheritance tree must be run.\nAn object is only completely formed when all the superclass parts of itself are formed\n2.5.Life of Objects and Variables• Life of an object:\n depends only on the life of reference variables referring to it.\n– Object is alive (or dead) if its reference is alive (or dead).\n• Variable lifetime:\n– same for primitive and reference variables;\n– different for local and instance variables\n\n\n\n\n\n\n\n\n\nlocal variables: live only within the method that declared it\n Is alive as long as its Stack frame is on the Stack\ninstance variables: live for as long as object they belong to lives.\n2.6.GC（简单介绍）Objects in Java are dynamically allocated and created on demand:\n– memory space for an object is allocated at runtime, not at compile time;\n– the new statement causes the memory for an object to be allocated\n (similar to the C malloc() function)\njava不会内存泄漏，因为有GC动态调整存储空间\nIf an object has only one reference to it and the Stack frame holding it gets popped off the Stack, then the object is now abandoned in the Heap.\n如果没有引用变量指向一个对象，那么这个对象将被GC回收\nMaking an Object Eligible for GC：\n(1) The reference goes out of scope, permanently.\n(2) The reference is assigned to another object.\n(3) The reference is explicitly set to null.\nSetting a reference variable to null (it means no object)\n\nfinalizer（终结方法）：The opposite of a Java constructor is a finalizer; it can sometimes be used for the cleanup of an object.\n\n3.常用类3.1.Math类3.1.1方法（全部为类方法）\n\nMath类中成员方法没有意义，所以没有成员方法\nMath类不能实例化\n\n\n\n\n\n\n\n\n\n• Classes that can’t be instantiated: \n– Abstract classes and interfaces.\n– Classes with private constructors.\nOnly code inside the class can invoke a private constructor!\n\nMath类设计如上：不能实例化\n3.1.2利用static final定义变量– Variables that are static and final cannot be changed.\n习惯变量名全大写\nInitialisation of static final variables（两种初始化方法）:\n– When the variable is declared.\n– In a static initialiser: block of code that runs when a class is loaded, before any code can use the class.\npublic class Bar&#123;\npublic static final double BAR_SIGN;\nstatic &#123;\nBAR_SIGN = (double) Math.random();\n&#125; \n&#125;\n\n\n\n3.2.Random ClassThe Random class is part of the java.util package and provides methods that generate random numbers.\nimport java.util.Random;\npublic class RandTest &#123;\npublic static void main(String[] args) &#123;\nRandom r = new Random();\nfloat aRandomFloat = r.nextFloat();\nint aRandomInt = r.nextInt();\nSystem.out.println(\"A random float is \" + aRandomFloat);\nSystem.out.println(\"A random int is \" + aRandomInt);\n&#125; \n&#125;\n\n\n\n\n\n\n\n\n\n3.3.包装类(Wrapper Classes)把基本数据类型包装成类\n used when a variable of a primitive type needs to be treated as an object.\nWrapper classes are part of java.lang package no need to import them:\n\n注意除了int和char其余均为首字母大写\n基本数据类型与字符串的转换：\n\nint a=Integer,parssInt(s)\n\n3.2.1装箱、拆箱（Wrapping versus Unwrapping）\nint i = 10;\nInteger iWrapped = new Integer(i);\nint unWrapped = iWrapped.intValue();\n\nAutoboxing自动装箱（包装类和基本数据类型等效使用）\nautomatic wrapping ： conversion from primitive type to wrapper object is automatic!\n体现在：\n\nMethod Arguments\nyou can pass either a reference or a matching primitive to a method that takes in a wrapper type; reverse is also true!\n\nReturn Values\nyou can return either a reference or a matching \nprimitive on a method with a primitive return type; reverse is also true!\n\nBoolean Expressions\nwhere a boolean value is expected, you can use \neither an expression evaluating to a boolean, a primitive or a matching \nwrapper.\n\nOperations on Numbers\nin operations where a primitive type is expected, you can use a wrapper type!\n\nAssignments\na variable declared as a wrapper (or primitive) can be assigned a matching wrapper (or \nprimitive)\n\nAll wrapper classes are subclasses of the Number abstract class (part of the java.lang package)\n\n\nwe can construct a Number object of type Integer:\nNumber num = new Integer(10);\n\n Often used when manipulating collections of numbers.\n\nSubclasses of Number provide constants to, e.g. represent the upper and lower\n\nbounds of the corresponding data type (MIN_VALUE and MAX_VALUE, \nrespectively)\n3.3.Scanner Class\nScanner class (of java.util package) allows a word to be specified as a delimiter（分隔符）\n\nString s = “Let your heart guide you.”;\nScanner myScanner = new Scanner(s);\nmyScanner.useDelimiter(“you”);\nwhile (myScanner.hasNext())\nSystem.out.println(myScanner.next());\n\nOutput is …\nLet\nr heart guide\n\nScanning primitive type values: several methods can be used to obtain a token with a primitive data type value\nString s = \"1 10 100 1000\";\nScanner myScanner = new Scanner(s);\nint sum = 0;\nwhile (myScanner.hasNext()) &#123; sum += myScanner.nextInt(); &#125;\nSystem.out.println(\"Sum = \" + sum);\n\n\n\nReading console input\nSystem.out.print(\"Please enter an int value: \");\n\nScanner myScanner = new Scanner(System.in);\n\nint i = myScanner.nextInt();\n\n4.RecursionMethods that call themselves, directly or indirectly\n需要Stop condition\n\nbrings additional overhead to programs:\n\n Everytime a program calls a recursive method, space needs to be assigned for the method’s local variables and parameters.  Extra memory required + time to manage the extra space\nTeaching Block41.GUIGUI: Method for interacting with a computer via the manipulation of text, images and “widgets”.\n使用awt和swing\njava.awt\njavax.swing//Javax表示扩展包\n\n1.1.  3 main concepts:– Component: An object that the user can see on the screen and can also interact with.\n– Container: A component that can hold other components.\n– Event: An action triggered by the user (e.g. pressing a key, clicking a mouse button).\n\n\n\n\n\n\n\n\n\nContainers: objects capable of containing other Componentobjects.\nComponents: single entities with no containment abilities. \n二者都是抽象类\n1.2.两种容器：• Top-level Containers: At least one of these containers must be present in any Swing application. \n顶层容器是进行图形编程的基础，一切图形化的东西都必须包括在顶层容器中。顶层容器是任何图形界面程序都要涉及的主窗口，是显示并承载组件的容器组件。\n• General-purpose Containers:Found in most Swing applications. \n中间容器是容器组件的一种，也可以承载其他组件，但中间容器不能独立显示，必须依附于其他的顶层容器\n\n1.3.awt包：The java.awt package contains most of the classes needed to create GUI applications and Applets in Java.\n几种其中的类：\n– Container Classes: Graphical widgets capable of containing collections of other graphical widgets (i.e. Panel, Window, Dialogand Frame).\n– Component Classes: Atomic graphical widgets like Button, Menuand List. \n– Layout Manager Classes: Control the layout of component objects on&#x2F;in container objects.\n– Primitive Graphics Classes: Control and access primitive graphics like Point, Rectangle and Polygon. \n– Event Handling Classes: Deal with events received from the GUI and other system items.\n– Listener Classes: Receive events from graphical components and act on them\n\n制作GUI步骤：\n\n\nMake a frame: create an instance of JFrame\nMake a widget (e.g. make a button or text field)\nAdd the widget to the frame\nDisplay the frame: must give it a size and make it visible\n\n1.4.Containers（主要用swing）常用的containers包括：JDialog JFrame JPanel ScrollPane等等\n1.4.1.JFrame窗体（基础）JFrame 是 Swing 组件的顶层容器，该类继承了 AWT 的 Frame 类\nimport javax.swing.JFrame;\n\npublic class FrameDemo extends JFrame &#123;\n\n        public FrameDemo() &#123;\n\n        this.setTitle(\"EBU4201 Demo JFrame\");\n\n        this.setSize(250, 100);\n\n        this.setVisible(true);\n\n&#125;\n\npublic static void main(String[] args) &#123;\n\nFrameDemo myFrame = new FrameDemo();\n\n&#125; \n\n&#125;\n\n\nYou can extend Frame in your program (more common),or instantiate the Frame class in your own class (less common) to build a basic GUI. \n\n通常在frame类中定义好组件，在main中实例化\n\n未调用方法设置时，JFrame大小为0，且不可见\n\n当创建一个 JFrame 类的实例化对象后，其他组件并不能够直接放到容器上面，需要将组件添加至&#x3D;&#x3D;内容窗格&#x3D;&#x3D;，而不是直接添加至 JFrame 对象。示例代码如下：\n\n\nframe.getContentPane().add(b);\n\n\n\n常用的API方法:\n\n\n\n\n方法签名\n方法功能\n\n\n\nsetLocation(int x, int y)\n设置组件的位置。\n\n\nsetSize(int width, int height)\n设置组件的大小。\n\n\nsetBounds(int x, int y, int width, int height)\n同时设置组件的位置、大小。\n\n\nsetVisible(Boolean b):\n设置该组件的可见性。\n\n\nsetTitle(String s);\n设置标题栏\n\n\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n设置窗口关闭\n\n\n\n添加组件的方法：\n\n\n\n\n方法签名\n方法功能\n\n\n\nComponent add(Component comp)\n向容器中添加其他组件 (该组件既可以是普通组件，也可以是容器) ， 并返回被添加的组件 。\n\n\nComponent getComponentAt(int x, int y):\n返回指定点的组件 。\n\n\nint getComponentCount():\n返回该容器内组件的数量 。\n\n\nComponent[] getComponents():\n返回该容器内的所有组件 。\n\n\n\n\n\n\n\n\n\n\n\nadd两次相同的控件后，会把前面的自动取消掉\n1.5.Event handle(事件处理)\nA (user) event is triggered any time when some sort of defined signal is received by the program. \n\nAn event is generated by external user actions\n\n.*表示该包内所有引用类\n\n\njava.awt.event.*\n\n\nYou need an listener（监听器） and a source（源） for each event\n\n​     一个事件源可以拥有多个事件监听器\n\nListener Interface: the bridge between the listener (the user code) and the event source (e.g. the button).\n\nEvent source: object that can turn user actions (e.g. click a mouse, close a window) into events.\n\nEvery event type has a matching listener interface：\n\n\n\n\n创建event handle步骤：\n1.首先创建事件源组件对象（比如按钮）；\n2.自定义类，实现XxxListener接口，重写方法；Implement the ActionListener interface:\n\n\npublic class MyClass implements ActionListener &#123;...&#125; \n\n​     3.调用事件源组件对象的addXxxListener方法完成&#x3D;&#x3D;注册监听&#x3D;&#x3D;Register with the widget: \nsomeComponent.addActionListener(instanceOfMyClass); //通常直接用this代指\n\n​     4.重写监听接口中的actionPerformed（e）方法 Define the event-handling method:\npublic void actionPerformed(ActionEvent e) &#123;\n// code that reacts to the action ...\n&#125;\n\n​    举例：\n\n方法一：相当于把程序所在类当成了监听类\n\n\n\n方法二：使用匿名内部类：\n不用写implement\n\n\n​      deal with multiple event sources:\n\nRegister each widget with the required listener and then determine which widget generated the event.\n\nUse an anonymous inner class for each event source.\n\nUse a specialised inner class for each event source.\n\n\nminusButton.addActionListener(new ActionListener() &#123;\n         public void actionPerformed(ActionEvent e) &#123;\n         label.setText(\"\" + (--number));\n    &#125;\n  &#125;\n);\n\n\n方法三：使用内部类：在主界面的类中不实现接口，而是在内部类中实现\nsomeComponent.addActionListener(new innerclassName);\n\n\n  \n原理：例如，如果鼠标单击了按钮对象 Button，则该按钮 Button 就是事件源，而 Java 运行时系统会自动生成 ActionEvent 类的对象 ActionEvent，该对象中描述了单击事件发生时的一些信息。之后，事件监听器对象将接收由 Java 运行时系统传递过来的事件对象 ActionEvent，并进行相应的处理。\n\n1.6.常用component：添加component的方式：\nmyFrame.getContentPane().add(myButton);\n\n1.6.1JLabel: component that you can put text into.\nWhen creating a label, you can specify the initial value and the alignment （对齐方式）you wish to use within the label.\nJLabel myLabel = new JLabel(“text”, JLabel.RIGHT);\n\n1.6.2 JButton extends Component, displays a string and delivers an ActionEvent for each mouse click.\n– Normally buttons are displayed with a border. \n– In addition to text, JButtons can also display icons\nJButton myButton = new JButton(“text”);\n\n\n\n常用组件的介绍\n\n\n\n组件名称\n定义\n\n\n\nJButton\n代表Swing按钮，按钮可以带一些图片或文字\n\n\nJCheckBox\n代表Swing中的复选框组件\n\n\nJComboBox\n代表Swing下拉列表框，可以在下拉显示区域显示多个选项\n\n\nJFrame\n代表Swing的框架类\n\n\nJDialog\n代表Swing版本的对话框\n\n\nJLabel\n代表Swing中的标签组件\n\n\nJRadioButton\n代表Swing单选按钮\n\n\nJList\n代表能够在用户界面中显示一系列条目的组件\n\n\nJTextField\n代表文本框\n\n\nJPasswordField\n代表密码框\n\n\nJTextArea\n代表Swing中的文本区域\n\n\nJOptionPane\n代表Swing中的一些对话框\n\n\n1.6.LayoutLayout Manager: An interface that defines methods for positioning and sizing objects within a container.\n在java.awt包中\nJava defines several default implementations of LayoutManager. \n\nJFrame默认使用BorderLayout管理其内部组件布局;\n\nJPanel默认使用FlowLayout管理其内部组件布局；\n\nJScrollPane 默认使用 BorderLayout 管理其内部组件布局； \nGeometrical placement in a Container is controlled by a LayoutManager object.\n设置Frame为最佳大小(打开窗口就为这么大不用resize)\nframe.pack();\n\nLayouts allow you to format components on the screen in a platformindependent way.\n– FlowLayout\n– GridLayout\n– BorderLayout\nStep 1: Create the layout.\nStep 2: Invoke the setLayout() method on the container to use the new layout.\nJPanel p = new JPanel();\np.setLayout(new FlowLayout());\n\nor\nJPanel p = new JPanel(new FlowLayout());\n\n1.6.1.FlowLayoutis the default layout for the JPanel class. \n– If the screen is resized, the components’ flow will change based on the new width and height.\n屏幕resize时，每行按钮个数会变，但是按钮大小不会变\nWhen you add components to the screen, they flow left to right(centered), based on the order added and the width of the screen. \n– Constructors: \n• FlowLayout()\n• FlowLayout(int align)\n• FlowLayout(int align, int hgap, int vgap)\n!\n1.6.2.GridLayout\n\n\n构造方法\n方法功能\n\n\n\nFlowLayout()\n使用默认 的对齐方式及默认的垂直间距、水平间距创建 FlowLayout 布局管理器。\n\n\nFlowLayout(int align)\n使用指定的对齐方式及默认的垂直间距、水平间距创建 FlowLayout 布局管理器。\n\n\nFlowLayout(int align,int hgap,int vgap)\n使用指定的对齐方式及指定的垂直问距、水平间距创建FlowLayout 布局管理器。\n\n\n\nGridLayout arranges components in rows or columns:\n\n– If number of rows is specified, the number of columns will be the number of components divided by the rows.（组件数除行数）\n– If number of columns is specified, the number of rows will be the number of components divided by the columns.（组件数除列数）\nGridLayout 布局管理器将容器分割成纵横线分隔的网格 ， 每个网格所占的区域大小相同。当向使用 GridLayout 布局管理器的容器中添加组件时， 默认从左向右、 从上向下依次添加到每个网格中 。\n 与 FlowLayout不同的是，放置在 GridLayout 布局管理器中的各组件的大小由组件所处的区域决定(每个组件将自动占满整个区域) 。    \n也就是说当窗口resize时，每行每列按钮个数不变，大小会随着屏幕改变\n– Constructors: \n• GridLayout():default of 1 column per component, in a single row. \n• GridLayout(int rows, int cols) \n• GridLayout(int rows, int cols, int hgap, int vgap) \n1.6.3.BorderLayout\n\n\n构造方法\n方法功能\n\n\n\nBorderLayout()\n使用默认的水平间距、垂直 间距创建 BorderLayout 布局管理器 。\n\n\nBorderLayout(int hgap,int vgap):\n使用指定的水平间距、垂直间距创建 BorderLayout 布局管理器。\n\n\n如果不往某个区域中放入组件，那么该区域不会空白出来，而是会被其他区域占用\n\nframe.add(new Button(\"西侧按钮\"), BorderLayout.WEST);\nframe.add(new Button(\"南侧按钮\"), BorderLayout.SOUTH);\nframe.add(new Button(\"北侧按钮\"), BorderLayout.NORTH);\nframe.add(new Button(\"中间按钮\"), BorderLayout.CENTER);\n\n\n\n1.7.Three types of graphics in GUI1.7.1.Graphics class:Java graphics are based on pixels (small dot on the screen that can be accessed).像素\n A pixel is identified by a pair of numbers(coordinates) starting at zero, (x,y):\n\n• x &#x3D; horizontal position (increases left to right)\n• y &#x3D; vertical position (increases top to bottom)\n\nStep 1: Make a paintable widget.\n• Create subclass of JPanel &amp; override the paintComponent() method.\n• Put all the graphics code in the paintComponent() method.\n• The paintComponent() method is called only by the JVM; the programmer does not call it!\n• It takes a Graphics object – drawing canvas for what is displayed on the screen\nimport java.awt.*;\nimport javax.swing.*;\nclass MyDrawingPanel extends JPanel &#123;\npublic void paintComponent(Graphics g) &#123;\ng.setColor(Color.red);\ng.fillRect(50,50,80,50);\n&#125; &#125;\n\n\n\n\n\n\n1.7.2.Graphics2D Class\n1.7.3.Color ClassJava has a Color class.\n\nTo define the colour of an object, you can directly use the static colour variables of the Colorclass.\n\n\npublic void paintComponent(Graphics g) &#123;\ng.setColor(Color.red); // g object becomes red\ng.drawLine(10,10,200,200); // draw a red line\n&#125;\n\n\n\n• You can also set your own colour by choosing an RGB value:\nColor myColor = new Color(r,g,b)\n\n\n2.Exception Handling\nSome causes of error situations:\n\n– Incorrect implementation \n– Inappropriate object request\n– Inconsistent or inappropriate object state\n\nprogramming errors\n– Trying to access an array out of bounds \n this throws an ArrayIndexOutOfBoundsException runtime error.\n– Attempting to divide by zero \nthis throws an ArithmeticExceptionruntime error\n\n\n\n\n\n\n\n\n\n\n\nException: an object that signals to the calling code, the occurrence of an unusual condition.\nExceptions are objects, subclasses of **java.lang.Exception **class\n2.1.Checked versus Unchecked Exceptions异常的分类：\nThrowable类是所有异常的根\n异常可以分为：系统错误、异常、运行时异常。\n\n系统错误（Error）、运行时异常（runtime exception）被称作免检异常（Unchecked exception）Unchecked exceptions: \n– Subclasses of RuntimeException. \n– Used for unanticipated failures.\n– Where recovery is unlikely.\n\nSome exceptions thrown by Java class libraries are called run-time exceptions\n当出现这样的异常时，总是由虚拟机接管（提供好现成的异常对象）。\n比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。\n\nJava does not force client code to catch run-time exceptions (also called unchecked exceptions), because: \n\n不强制要求写免检异常的捕获\n– Run-time exceptions can occur so frequently that the cost of checking by the compiler would be very big.\n– You can catch them if you believe there is ever likely to be a problem.\n– Ideally, you should instead check input pre-conditions first!\n\n\n\n\n其他异常都为必检异常（checked exception）\nChecked exceptions: \n– Subclasses of Exception. \n– Used for anticipated failures.\n– Where recovery may be possible.\n编译器会强制程序员检查并处理必检异常\n\n\n2.2.Run-Time Error HandlingRun-time programming errors are the most difficult to deal with\nThere’s no support given at programming language level for catching and managing errors in most languages.\nUsing exceptions enables potential run-time problems to be noticed at compile time\n\n\nthrows&#x2F;throw\n抛出异常（不处理）\n\nthrow:抛出异常的关键字\nWhen writing code, we can throw exceptions, and thus force any clients that use it to catch these exceptions.\nthrow new XXXXException(\"错误信息\")\n\nXXXXException必须为系统封装过的类，或者利用自己创建的其子类\n\nthrows:声明异常的关键字\n不管这个方法中是否有throw语句，只要这个方法中调用过抛出异常的方法，就要给这个方法加throws（调用链中的每一层都要加）\n表明此方法可能会抛出某个异常（抛没抛还得看throw的条件）\n用于&#x3D;&#x3D;方法&#x3D;&#x3D;头：\npublic void myMethod() throws XXXExceotion&#123;\n    \n&#125;\npublic void myMethod() throws XXXExceotion1,XXXExceotion2,XXXExceotion3&#123;\n    //多个异常\n&#125;\n\n\n\n\n\n\n\n\n\n\nJavadoc documentation syntax to indicate that method throws an exception: @throws ExceptionType reason\nyou don’t want to catch exceptions, but want client code to handle them\n当编写类的人不打算处理一个异常，只是抛出此异常留给写实现类的人去处理\nin this case, you should declare that your method throws them\n\n\n\n\n\n\ntry&#x2F;catch Block\n捕获 异常并处理（需要有异常被抛出）\nWhen a program is run, the JVM will attempt to execute each statement in the try block in turn.\nIf any statement throws an exception then either:\n– the catch block corresponding to this exception will be executed; \n– the method in which this code lies will itself throw the exception\n如果使用系统jvm默认异常处理方式时：\n先从try内部开始执行，直到出现异常（此时会自动生成一个默认异常类对象，并提交给系统，而系统运行时接受到异常，从catch中找匹配的异常类，然后进行异常处理）\n如果使用自己建的异常类（try中某个有异常的方法在声明时必须抛出异常）。\nA try&#x2F;catch section can also have a finally section, usually to tidy up afterwards\n无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\n\n\ntry &#123;\n// code that can throw exceptions E1, ..., En\n// ...protect one or more statements here\n&#125;\ncatch (E1 e1) &#123;\n// code to handle exception E1\n// ...report and recover from the exception here\n&#125;\n// ...\ncatch (En en) &#123;\n// code to handle exception En\n// ...\n&#125;\nfinally &#123;\n// perform any actions here that are common, regardless of whether or not an exception is thrown\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n如果一个方法声明了一个必检异常，则必须使用try-catch中调用处理，或者声明要用用throws抛出\n2.3.Creating Exception ClassesJava programmers can create their own exception classes.\n构建一些Java不认为是异常的异常\n比如：-100岁\nUser exception classes are like any other class, but they must extend the Exception class.\npublic class MyException extends Exception &#123;\npublic MyException() &#123;\n     super(); // call constructor of parent Exception\n     // other appropriate code\n&#125;\npublic MyException(String s) &#123;\n      super(); // call constructor of parent Exception\n      // other appropriate code\n&#125; &#125;\n\n\n\nIf a program fails to catch an exception(没捕获只抛出), the JVM interpreter prints information about the exception, and the location where it occurred.\n\n2.4.Assertions in Java在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。\nJava statements that enable you to assert (or check) an assumptionabout your program\n一般来说，assertion用于保证程序最基本、关键的正确性。\nAssertions are used to ensure program correctness and avoid logic errors. \n– For internal consistency checks, e.g. to check the object state following mutation (due to a setter method being called).\n– During development (to enable debugging) but usually removed in production versions, e.g. via a run-time option.在产品代码中移除\n\nJava assertions are declared via an assert statement\n\nassert assertion-expression \nassert assertion-expression : detailMessage\n\n– The assertion-expression（boolean类型） expresses something that should be true at this point.\n– The detailMessage is a primitive type or an Object value（是要传入AssertionError构造方法的信息，会打印该错误信息）.\n– An AssertionError exception is thrown if the assertion is false.（如果assertion是false就抛出一个AssertionError）是Error的子类\n\nAssertions are disabled by default, at runtime. But you can always,\n– enable your program to run with assertions by calling it with the \n-enableassertions (or in short form, -ea) switch\n– disable your program from running with assertions by calling it with the \n-disableassertions (or in short form, -da) switch\n– enable&#x2F;disable assertions at package level and at class level.\n\n\njava –ea AssertionDemo\njava –da Test\njava –ea:ClassUsedByTest Test\njava –da:ClassUsedByAssertionDemo AssertionDemo\n\n\n不要使用assertions的情况\n\n– Should not be used to check the validity of a public method’s argument(s). \n对于公共函数，我们通常不使用assertion检查，因为一般来说，公共函数必须对无效的参数进行检查和处理。而私有函数往往是直接使用的\n– Do not include normal functionality(不要用于改变程序中参数的操作，断言不应该以任何方式改变程序的状态)\n// Incorrect use of assertions:\nassert book.remove(name) != null;\n\n\n\n3.File I&#x2F;OData stored in variables, arrays, objects is temporary: once a program has finished executing, information is lost!\nSaving data requires information to be stored in a file on a disk&#x2F;CD\n\ntwo ways of saving data：\n\nUsing serialisation：[Java 序列化](Java 序列化 | 菜鸟教程 (runoob.com))\nThe data stored will only be used by the Java program that generated it. \n\nUsing a file (such as a plain text file)\n\n\n\n\nThis interaction with an external source is what we refer to as Input&#x2F;Output: \n– Input: to bring in information (read) \n– Output: to send out information (write) \ncan be \n– anywhere: \n– of any type (any object)\n\nJava input&#x2F;output makes use of streams: \n– A stream is a connection to a source of data or to a destination for data (sometimes both).\n– Streams can represent any data, so a stream is a sequence of bytes that flow from a source to a destination.\nwe read information from an input stream and write information to an output stream\n\n\n\n\n\n\n\n\n\nA program can manage multiple streams simultaneously\n1.two broad categories of streamsJava has two broad categories of streams:\n– byte streams（字节流）\nmachine-formatted data（无法用文本编辑器读取二进制文件）\n• InputStream\n• OutputStream\n\n– character streams（文本流）\nfor human readable data（可以用文本编辑器处理）\n• Reader\n• Writer\n\nText files contain data represented in human-readable form. \n\nBinary files contain data represented in binary form.\n\n\n2.java.io.File ClassFile 类：\n\nFiles live in directories within the file system.\n– Complete file name (represented by a String) consists of the path + name of file\n\nFile f1 = new File(\"E:\\\\文件夹\\\\文件名\")\n\njava中使用\\代表Windows中的\\ 。\njava.io.File: contains methods to obtain file properties, for renaming and deleting files. \n– A wrapper class for a file’s name and directory path: represents an abstract pathname. \n– It hides file system differences.\n– No exception is thrown if file does not exist\nConstructors：\n\nmethods\n\n\nboolean exists() &#x2F; boolean isDirectory() &#x2F; boolean isFile()\n\nboolean canRead() &#x2F; boolean canWrite()\n\nboolean delete(): returns true if file successfully deleted\n\nString getAbsolutePath(): returns complete absolutefile&#x2F;directory name\n\nboolean renameTo(File dest): returns true if operation successful\n\nlong length(): returns length of the file in bytes\n\nString[] list(): returns an array of strings containing the list of files in this directory\n\n\n\n4. Reading from &#x2F; Writing to files1. Open file\n– Needs the file’s name and maybe its location (path).\n– Open file by creating an instance of an appropriate stream class.\n2. Perform operations\n– Read from and&#x2F;or write to the file.\n– Call instance methods that belong to the &#x3D;&#x3D;stream object&#x3D;&#x3D;’s class.\n3. Close file(一定要释放资源)\n– Any class from InputStream, OutputStream, Reader and Writer has a close() method.\n\n\n\n\n\n\n\n\n\n File I&#x2F;O can cause a large number of exceptions to be thrown.\n5.FileReader versus FileWriterFileReader \nJava FileReader类继承自InputStreamReader类。 FileReader用于读取字符流。FileReader类有几个构造函数来创建所需的对象。 以下是FileReader类提供的构造函数列表。 \n\njava.io.FileNotFoundException will occur if you attempt to create a FileReader with a nonexistent file.\n\n记得用close（）关闭所有与之相关的系统资源\nFileWriter\n在给出 File 对象的情况下构造一个 FileWriter 对象。\nFileWriter(File file)\n\n在给出 File 对象的情况下构造一个 FileWriter 对象。\nFileWriter(File file, boolean append)\n\n构造与某个文件描述符相关联的 FileWriter 对象。\nFileWriter(FileDescriptor fd)\n\n在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值（为true则下一次写入在本次末尾进行）。\nFileWriter(String fileName, boolean append)\n\nFileWriter: If the file doesn’t exist, a new file will be created.\n\nvoid write(int c)\nvoid write(byte[] cbuf)\nvoid write(char[] cbuf,int off,int len)\nvoid write(String str)\nvoid write(String str, int off,int len) \n记得用close（）关闭所有与之相关的系统资源\nBufferedReader\n\nBufferedReader维护一个内部的8192个字符缓冲器。在BufferedReader中进行读取操作期间，将从磁盘读取一部分字符并将其存储在内部缓冲区中。 并且从内部缓冲区中单独读取字符。因此，减少了与磁盘的通信次数。\n为了创建一个BufferedReader，我们必须首先导入java.io.BuferedReader包。导入软件包后，就可以创建阅读器。\n&#x2F;&#x2F;创建一个FileReader\nFileReader file &#x3D; new FileReader(String file);\n\n&#x2F;&#x2F;创建一个BufferedReader\nBufferedReader buffer &#x3D; new BufferedReader(file);\n\n在上面的示例中，我们创建了一个名为buffer的BufferedReader和一个名为file的FileReader。\n此处，BufferedReader的内部缓冲区的默认大小为8192个字符。 但是，我们也可以指定内部缓冲区的大小。\n&#x2F;&#x2F;创建一个具有指定大小的内部缓冲区的BufferdReader\nBufferedReader buffer &#x3D; new BufferedReader(file, int size);\n\nread()方法\n\nread() - 从阅读器的内部缓冲区读取单个字符\nread(char[] array) - 从阅读器读取字符并将其存储在指定的数组中\nread(char[] array, int start, int length)- 从阅读器读取等于length字符的数量，并从start位置开始存储在指定的数组中\n\nskip()方法\n要丢弃和跳过指定数量的字符，可以使用skip(int a)方法。\nreadline()方法（读取一行）\npublic String readline()\n\n**IOException **包含 FileNotFoundException 所以只需要抛出 IOException.\n4.Collection ClassesCollection in Java: “an object that groups multiple elements into a single unit”.\nJava provides several interfaces, implementations and algorithms for handling collections of objects, via its Java Collections Framework (see java.util package).\n集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象）。\nCollection是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素，JDK不提供此接口的任何直接实现,它提供更具体的子接口(如Set和List)的实现\ncollection的常用方法\n\n处理集合时的接口、实现类、算法\n\n\n4.1.集合的interface\nSet: A collection that contains no duplicate elements;（模拟数学中的集合）\n\nList: An ordered collection (also known as a sequence). Elements can be accessed by their position      in the list, and it is possible to search for elements in the list. Lists allow for duplicate elements\n\n\n\n\n\nMap: An object that maps keys to values. A map does not contain duplicate keys; each key can map to at most one value. \nEach key maps to one value only.\nMap 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。\n\n\n4.2.集合的实现类\n\narray 和arraylist: \narray 在初始化时必须确定长度\narray必须在分配值时必须确定位置（index）\n\nMap的实现类 HashMap \nThe HashMap class implements Map and is efficient for locating a value, as well as inserting and deleting a mapping.\nEntries are not ordered\n\n\nimport java.util.*;\npublic class HashMapTester &#123;\npublic static void main( String[] args ) &#123;\nMap&lt;String, String> petSounds = new HashMap&lt;String, String>();\npetSounds.put(\"cat\", \"Meow\"); petSounds.put(\"mouse\", \"Squeak\");\npetSounds.put(\"dog\", \"Woof\"); petSounds.put(\"guineaPig\", \"Squeak\");\nSystem.out.println(\"map = \" + petSounds);\nString val = (String)petSounds.get(\"dog\");\nSystem.out.println(\"Value for key 'dog' is: \" + val);\n&#125;\n&#125;\n\n\n\nJava Iterator（迭代器）不是一个集合，它是一个接口，可以用于访问、遍历集合\n其中的方法：\n\n调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\n调用 it.hasNext() 用于检测集合中是否还有元素。\n调用 it.remove() 将迭代器返回的元素删除。\nArrayList&lt;String> alist = new ArrayList&lt;String>();\n// Add Strings to alist\nfor (Iterator&lt;String> it = alist.iterator(); it.hasNext(); ) &#123;\nString s = it.next(); // No downcasting required.\nSystem.out.println(s);\n&#125;\n\n5.2-dimensional (2D) ArraysJava stores a 2D array as an array of arrays, e.g.\nint[][] nums = new int[5][4];\nnums = new int[5][]; // OK\nnums = new int[5][4]; // OK\n\nmust always specify the first dimension,do not need to specify the second dimension\nA 2D array of objects is an array of an array of references to objects 对象的reference的数组的数组\n利用arraylist实现二维数组\nArrayList&lt;ArrayList&lt;Integer>> topList =new ArrayList&lt;ArrayList&lt;Integer>>();\nfor (int i = 0; i &lt; 3; i++)\ntopList.add(new ArrayList&lt;Integer>());\nfor (int i = 0; i &lt; 3; i++) &#123;\nfor (int j = 0; j &lt; 3; j++)\ntopList.get(i).add(new Integer(i+j));\n&#125;\n\n6.SortingSelection sort\n\nFind largest number and put it in the last position.\n\nFind next largest number and put it next to last one.\n\nRepeat until finished.\n\n\nInsertion sort:\nList of values is sorted by inserting (repeatedly) an unsorted element into a sorted sublist until the complete list is sorted\nBubble sort:\n– Several passes are made through the array.\n– Each time, successive adjacent pairs are compared.\n• If pair is in decreasing order, order of values is swapped.\n• Otherwise, move on to next pair.\nvoid bubbleSort(double[] list) &#123;\nboolean changed &#x3D; true;\ndo &#123;\nchanged &#x3D; false;\nfor (int j &#x3D; 0;\nj &lt; list.length-1; j++)\nif (list[j] &gt; list[j+1]) &#123;\ndouble temp &#x3D; list[j];\nlist[j] &#x3D; list[j + 1];\nlist[j + 1] &#x3D; temp;\nchanged &#x3D; true;\n&#125;\n&#125; while (changed);\n&#125;\n\n7.Comparing objects在java中接口comparable使我们经常要接触到的，比如对集合或者数组进行排序，我们经常使用到Arrays.sort()或者Collections.sort().当集合中的对象是自定义的对象时，我们有两种方法能够使排序方法应用到自定义对象的集合（数组）中\nJava defines two ways of comparing objects:\n\nThe objects implement the Comparable interface.\n被排序的对象类要实现cmparable\n\nA Comparator object is used to compare the two objects.\n\n\n• If the objects are Comparable, they are said to be sorted by their “natural” order.（自然排序）\nA Comparable object can only offer one form of sorting. \n– To provide multiple forms of sorting, Comparators must be used.\n如果想对元素进行自然排序，必须在元素对象的类上实现comparable接口，该接口只有compareTo()一个方法。所以要重写compareTo()方法使其满足要求进行比较\n用sort方法 排序，表示升序排列（其算法简单来说就是每两个都比一次）    （默认调用compareTo 如果返回1 则认为比较的对象比本对象大（放在后边））\npublic class Employee implements Comparable&lt;Employee> &#123;\n    实现Comparable&lt;E>接口\n        \nint empID;\nString eName;\ndouble salary;\nstatic int i;\n    \npublic Employee(String name, double sal) &#123;\nempID = i++;\neName = name;\nsalary = sal; &#125;\npublic String toString() &#123;\nreturn \"EmpID = \" + empID + \"\\n\" + \"Ename = \" + eName + \"\\n\" +\n\"Salary = \" + salary;\n&#125;\npublic int compareTo(Employee o1) &#123;\n    \nif (this.salary == o1.salary) return 0;\nelse if (this.salary > o1.salary) return 1;\nelse return -1;\n&#125; &#125;\n\nimport java.util.*;\npublic class ComparableDemo &#123;\npublic static void main(String[] args) &#123;\nList&lt;Employee> ts1 = new ArrayList&lt;Employee>();\nts1.add(new Employee(\"Tom\", 40000.00));\nts1.add(new Employee(\"Harry\", 20000.00));\nts1.add(new Employee(\"Maggie\", 50000.00));\nts1.add(new Employee(\"Chris\", 70000.00));\n    \n\nCollections.sort(ts1);\n    \nIterator &lt;Employee> itr = ts1.iterator();\nwhile(itr.hasNext()) &#123;\nObject element = itr.next();\nSystem.out.println(element + \"\\n\");\n&#125; &#125; &#125;\n    \n\n\n\n细碎知识1.String类中的format方法format方法使用占位符进行格式化常规类型、字符类型和数值类型的占位符格式：%[index$][标识][最小宽度][.精度]转换符日期和时间类型的占位符格式：%[index$][标识][最小宽度]转换符与参数不对应的占位符格式：%[标识][最小宽度]转换符其中index表示参数列表中的位置上的值可用标识：\n\n\n\n标识\n含义\n\n\n\n-\n在最小宽度内左对齐，不可与0标识一起使用\n\n\n0\n若内容长度不足最小宽度，则在左边用0来填充\n\n\n#\n对8进制和16进制，8进制前添加一个0,16进制前添加0x\n\n\n+\n结果总包含一个+或-号\n\n\n空格\n正数前加空格，负数前加-号\n\n\n,\n只用与十进制，每3位数字间用,分隔\n\n\n(\n若结果为负数，则用括号括住，且不显示符号\n\n\n可用转换符：\n\n\n\n转换符\n含义\n\n\n\nb\n布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false\n\n\nn\n平台独立的换行符, 也可通过System.getProperty(“line.separator”)获取\n\n\nf\n浮点数型（十进制）。显示9位有效数字，且会进行四舍五入。如99.99\n\n\na\n浮点数型（十六进制）\n\n\ne\n指数类型。如9.38e+5\n\n\ng\n浮点数型（比%f，%a长度短些，显示6位有效数字，且会进行四舍五入）\n\n\ns\n字符串类型\n\n\nc\n字符类型\n\n\nString result1 = String.format(\"小明今年%d岁,他住在%s,他的月工资有%.2f\", 25,\"北京市\",6633.435);\nSystem.out.println(result1);//输出:小明今年25岁,他住在北京市,他的月工资有6633.44\n/*****************************************************/\ndouble num = 123.4567899;\nString result2 = String.format(\"%e\", num);\nSystem.out.println(result2);//输出：1.234568e+02\n\n2.javadocTo generate javadocdocumentation, type on the command line:\njavadoc -d docsfile.java \n\nView the docs with a web browser:\n – Start with the index.html file in the docs subdirectory.\n Java文档注释用法+JavaDoc的使用详解_阿★永的博客-CSDN博客_javadoc\n3.增强forfor 的其他语法\n\nfor (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体 \n借助这种语法，遍历一个数组的操作就可以采取这样的写法\nint[] integers = &#123;1， 2， 3， 4&#125;; \n\nfor (int i : integers) &#123; //等同于 int i;i&lt;integers;i++\n\nSystem.out.println(i);可以实现遍历\n&#125;\n\n4.导包\n\n5.Sting 和int 互换字串 String 转换成整数 int\nint i = Integer.parseInt([String]);\n\n将整数 int 转换成字串 String \nString s = Integer.toString(i);\n\nString s = \"\" + i;\n\n6.scannerimport java.util.Scanner;\nScanner sc = new Scanner(System.in);\ns.nextLine()\n\n7.运行错误和编译错误①编译错误一般指语法错误或者很明显的逻辑错误。        如：缺少分号，少写括号，关键字书写错误等， 在eclipse往往会画红线。     ②运行错误是在没有编译错误的基础上运行后产生的逻辑错误。         如：空指针异常，除数为0，越界访问等，一般会抛出异常。\n","slug":"java1","date":"2022-05-29T15:03:46.000Z","categories_index":"-java","tags_index":"大二下,BUPT,Java","author_index":"赫"},{"id":"5928bf74ef9f1a5ddcaab207604ef661","title":"产品开发 topic8","content":"Topic 8 – Detail Design using prototypesDetail Design\n\n\n⚫ Aim\n⚫ Control Documentation\n⚫ Departmental responsibilities\n Prototype \n⚫ Definitions: Prototype, Prototyping\n⚫ Phases of prototypes\n⚫ Uses of prototypes\n⚫ Principles of prototyping\n⚫ Planning a prototype\n⚫ Prototyping strategy\n\nDetail DesignControl documentation\n⚫The drawings or computer files describing the geometry of each part to be made and its production tooling\n⚫ The process descriptions for the fabrication and assembly of the product\n⚫ The specifications of the parts to be purchased\nDepartmental responsibilities\n⚫ Marketing\n⚫ Design\n:two:Prototype\nDefinitions: Prototype, Prototyping\n\nPrototype： an approximation of the product along one or more dimensions of interest（根据多方面兴趣得到的近似品）\nPrototyping is the process of developing an approximation of the product\n\nPhases of prototypes\n\nAlpha prototypes： used to assess whether the product works as intended\nBeta prototypes: used to assess reliability and to identify remaining bugs \nPre-production prototypes(试产原型): These are the first products produced by the entire production process\n\nUses of prototypes\n\n\nLearning\n\nAnswering questions about performance or feasibility \n\nCommunication\n\nDemonstration of a product to get feedback from all stakeholders\nA physical, tactile, 3D representation of a product is much easier to understand than a verbal description or even a sketch of a product\n\nIntegration\n\n","slug":"产品开发-topic8","date":"2022-04-24T10:20:23.000Z","categories_index":"","tags_index":"大二下,BUPT,产品开发","author_index":"赫"},{"id":"db6a37e551fd2d2414ba0fc93d6fc102","title":"产品开发 topic 7","content":"Topic 7 – System Level Design\n❑Aim of Phase 2. System- level Design\n\n\n❑ Product architecture – what is it?\n❑ Modular and integral architecture\n❑ Implications of product architecture\n❑ Role of the product architecture team\n❑ 4-step method for establishing the product architecture\n❑ Key outcomes\n\n:one:Product Architecture(产品架构)\nMeaning：the scheme by which the functional elements of the product are arranged into physical chunks and by which the chunks (块)interact\n\nallow the detailed design and testing of these physical blocks to be assigned to teams, individuals, and&#x2F;or suppliers\n\nchunks: contains physical elements of a product, made up of a collection of components which implement of the functions of the product\n\n\n:two:Modular &amp; integral architectureis key characteristic\n1.Modular\nEach chunk implements one or a few functions entirely.\n\n\n\ninteractions between chunks are well defined.\n\nsimplicity and reusability\n\n\n\n\n\n\n\n\n\n\n\nthree main types：\n\nSlot-modular (the most common type)\n\ndifferent type of interface, various chunks cannot be \ninterchanged\n\n\n\nBus-modular\n\ncommon bus to which the other chunks connect via the same type of interface\n\n\n\nSectional-modular\n interfaces are of the same type,no single element to which all the other chunks attach\n\n\n2.Integral\nFunctional elements are implemented by multiple chunks, or a chunk may implement many functions\n\n\n\ninteractions between chunks are poorly defined\n\nincreases performance and reduces costs\n\n\n3.integral and modular apply at several levels:​       ⚫ System\n​       ⚫ Sub-system\n​       ⚫ Component\n:three:Implications of product architecture1.Product change Modular chunks allow changes to be made to a few isolated functional elements of the product without affecting others\n2.Product variety\nRange of product models within a particular time period \n\nin response to market demand\n\n\nProducts built can be more easily varied \n3.Component standardisationThe use of the same component or chunk in multiple products\n4.Product performanceHow well a product implements its intended functions\n5.Manufacturabilityability of the team to design each chunk to be produced at low cost\n6.Product development managementResponsibility is usually assigned to a relatively small group\n:four:Role of Product Architecture Team⚫ subsequent product development activities \n⚫ manufacturing and marketing of the product\n:five:The 4 step methodStep 1 – Create a schematic of the product\nA schematic representes the team’s best understanding of the component elements of the product\n\nStep 2 – Cluster the elements of the schematic\nassigning and&#x2F;or clusteringeach of the elements of the schematic to a chunk\n\nfunctionality split\n\nfactors should be considered:\n\n\n\nGeometric integration and precision\nFunction sharing\nCapabilities of vendors\nSimilarity of design or production technology\nLocalisation of change\nAccommodating variety\nEnabling standardisation\n\nStep 3 - Create a rough geometric layout 2 or 3 dimensions or as physical models\nStep 4 - Identify the fundamental and incidental interactions two categories of interaction：\n\nFundamental：\n\nthose which correspond to the lines on the schematic that connect the chunks to one another\n\nIncidental：\n\n\nphysical implementation of functional elements\n\ngeometric arrangement of the chunks\n\n\n:six:Key Outcomes⚫ an approximate geometric layout of the product\n⚫ descriptions of the major chunks \n⚫ documentation of the key interactions among the chunks\n","slug":"产品开发-topic-7","date":"2022-04-21T12:04:31.000Z","categories_index":"","tags_index":"大二下,BUPT,产品开发","author_index":"赫"},{"id":"6532d66c6049bb9292e1cfcb7c1044f9","title":"wordle game","content":"User guide for Wordle gameqm Java 的迷你project：利用swing实现一个简单wordle 游戏\n\n可执行文件如下：\n\n​     链接：https://pan.baidu.com/s/17MtqNlHzGVF0AtWP499R-w​          提取码：bupt\n\n源码随后更新\n\nThank you for choosing this game.\n:one:How to run this interesting game?To run this game you should download the *entire* java miniproject file and open the wordleTest.java file in the src directory. Or you can just open wordle.exe to play.\n:two:Base- ruleGuess the *WORDLE* in 6 tries(must be word). Each guess must be a valid 5 letter word(without enter). After each guess, the color of the tiles will change to show how close your guess was to the word.\nExamples:\n \nThe letter *c* and *h* are in the word and in the correct spot.\nThe letter *a* is in the word but in the wrong spot.\nThe letter *b* and *e* is not in the word in any spot.\nYou can type letters through the keyboard and can modify it with backspace before the word ends.\n:three:menu setting  \nl You can adjust the difficulty of the game via *difficulty* in the menu bar\n \n\nSimple mode:  5 minute countdown.\n\nCommon mode 3 minute countdown.\n\nHard mode: 1 minute countdown.\n\nNoLimit mode(default)with out time limit.\n\n\nOnce you choose a mode, you can’t change it again until the game is over\nAfter you select the difficulty of the game, the time remaining will be displayed at the bottom of   the interface\n \nWhen the progress bar becomes empty, it means failure\nYou can get help via *help* in the menu bar.\n  \nYou can adjust get a letter of wordle via hint in help.\n   If you want get more, press again(no more than 5 times)!\n You can get this user guide via how to play in *help.\n:four:Success:If you successfully guess the word within six chances. Congratulations, you made it. You can exit the program by selecting OK, or select Next to start a new round.\n\n","slug":"Wordle game","date":"2022-05-28T10:44:58.000Z","categories_index":"","tags_index":"大二下,BUPT,Java","author_index":"赫"},{"id":"4dd9bc53bcd2b7b17e66aaf846825adc","title":"DFT的对称性","content":"DFT的对称性一直搞不懂的dft对称性\n共轭对称与奇偶对称\n奇偶对称是基于实数域来定义的：\n偶对称：\n\n 奇对称: \n\n\n共轭对称是基于复数域来定义的\n 共轭对称 :\n  \n 共轭反对称 :\n  \n\n\n\n\n\n\n\n\n\n\n\n偶对称是共轭对称在实数域中的特殊形式\nDFT对称特性时域为实函数，频域共轭对称\n时域为虚函数，频域共轭反对称\n\n把上述两个结论综合表示，就是令x[n]为复序列，有如下关系：\n\n\n这里Xe、Xo表示共轭对称部分和共轭反对称部分\n其余结论见：DSP学习杂记——DTFT、DFS、DFT对称性总结_wjpwjpwjp0831的博客-CSDN博客_dft对称性\n","slug":"DFT的对称性","date":"2022-05-26T10:30:08.000Z","categories_index":"","tags_index":"DSP,大二下,BUPT","author_index":"赫"},{"id":"e1afc39606f833ed1d642f6080d9ac84","title":"频率泄露","content":"频率泄露在上课学习时，实在没有听懂其具体含义，通过一些资料补充一些个人理解。（理解可能存在偏差，欢迎指正）这部分可能偏理解一些，课后作业也没有涉及\n\nDFT得出：\nDFT是对DTFT频域采样后再进行加窗处理得到的。\n\n首先，对于DTFT的频域采样处理，这时根据采样定理，我们不难发现，如果频域采样那么时域一定会发生一个频谱的搬移，所以需要加窗来选取其中一个部分，从而得出DFT。\n\n矩形窗对应频域是一个sinc函数：\n\n\n泄露现象：对具有N个数的输入序列，进行一个N点的DFT变换，产生一个具有N个点的频域序列。我们知道频率域坐标中横坐标的间隔实际上是分辨率fs&#x2F;N；如果输入信号的频率恰好是坐标轴间隔的整数倍，那么加窗可以很好的反映DFT的频率特性（也就是可以用下式表示）。\n\n\n\n\n1.输入信号的频率是坐标轴间隔的整数倍:\n此时所有采样点（sin函数对应频率点以外）都与sinc函数0点重合，观测起来就是m&#x3D;k处的一个冲激\n\n2.输入信号的频率不是坐标轴间隔的整数倍:\n就会发生谱泄露，其能量会被泄露到频域上的N个序列点上，可以理解峰值被相邻的基本函数“分摊”了\n\n也就是采样点不在sinc函数的0点处\n","slug":"频率泄露","date":"2022-04-24T03:14:31.000Z","categories_index":"","tags_index":"DSP,大二下,BUPT","author_index":"赫"},{"id":"87de77321c17694debcf37f7f3b81f68","title":"产品开发 topic 6","content":"Topic 7 – System Level Design\n⚫What is innovation?\n⚫ Types of innovation\n⚫ Models of innovation\n⚫ What makes an innovative company?\n\n \n\n:one:What is innovation?\nmeaning to renew, to make new or to alter, new way of doing things\nresearch product to increase turnover(营业额) and profit \nIs successful implementation of a new  improved product or process, a new marketing method, or a new organisational method\n\n\n\n\n\n\n\n\n\n\n:interrobang:Invention vs Innovation\n-Innovation &#x3D; theoretical conception + technical invention + commercial exploitation\n-invention can be an innovation even if it is unsuccessful\n:two:Types of innovation⚫ Product (or service) innovation\n⚫ Process Innovation\n\n1.Product Innovation\nrelate to actual products\n\nAdvantages:\n⚫ Increased market share\n⚫ Public relations \n⚫ Enhanced reputation \n⚫ Build customer loyalty\n⚫ Added value\n⚫ Higher prices and profitability\n⚫ Competitive advantage\n\nCan lead to process, managementand&#x2F;or organisational innovation\n\n\n2.Process Innovation\nFind more efficient and effective ways of\n\n   Producing and Delivering existing products\n\nAdvantages:\n⚫ Reduced costs\n⚫ Improved quality\n⚫ More responsive customer service\n⚫ Greater flexibility\n\nDisadvantages：\n⚫Loss of jobs\n⚫ re-training of workers\n\n\n:three:Models of innovation1.Linear modelsTechnology push\n\nMarket pull\n\nUniversities &amp; industry liaison（联络）\n\n2.Simultaneous coupling\n3.Interactive\nTakes simultaneous coupling one step further\nNo starting point \nlinks between the organisation (internal  external)  with the marketplace and science base .\n\n\n:four:What makes an innovative company?\nGrowth orientation（定位）：long-term process、 requir investment.\n\nvigilance（警觉）：By SWOT analysis Identifying threats, opportunities.\n\ncommitment to technology(技术承诺)：Need Long-term commitment.\n\nacceptance of risks：Risk assessment strategies and balanced product portfolios.\n\ncross-functional cooperation：removal of inter-departmental conflict.\n\nReceptivity：the ability to accept technologies from outside of the company\nJoint activities allow knowledge sharing.\n\nslack(宽松管理)：Allowing individuals time to think and investigate . flexibility on milestones.\n\nadaptability: Ability for companies to adapt as required.\n\ndiverse range of skills.\n\n\n","slug":"产品开发-topic-6","date":"2022-04-21T10:41:32.000Z","categories_index":"","tags_index":"大二下,BUPT,产品开发","author_index":"赫"},{"id":"a5ba081d42d4ddecbbc2164f3d549c44","title":"Database note","content":"Database1.Overview of Data Models1.1.关系数据模型（Relational Model）\n\n\n\n\n\n\n\n\nA two-dimensional table called a relation\nEach relation has a name——关系名\nProvides a simple, limited approach to structuring data\nProvides a limited, yet useful, collection of operations on data\n1.1.1.Attribute(属性)The columns of a relation are named by attributes\n\n\n\n\n\n\n\n\n\nAny two attributes of a relation can’t have same name\n\n\n​                                      第一行就是每列的attribute\n1.1.2.Schemas(模式)\n\n\n\n\n\n\n\n\nRelation schema &#x3D; relation nameand the set of attributes.(关系名+属性集)\nExample:\nMovies (title, year, length, genre)\n\nMovies (title: string, year: integer, length:integer, genre: string)\n\n关系名大写开头、属性名小写开头\n数据库是collection of relations\n数据库的关系模式集合——Relational database schema\n1.1.3.Tuples (元组&#x2F;⾏)\n\n\n\n\n\n\n\n\nThe rows of a relation, other than the **header rowcontaining the attribute names,**are called tuples.\nA tuple has one **component(**属性的分量) for each attribute of the relation.\nUse commas(,)逗号 to separate components, and **use parentheses(圆括号) to surround the tuple\n\n\nExample: (‘Star Wars’, 1977, 124, ‘sciFi’)\n1.1.4.Domains（域）\n\n\n\n\n\n\n\n\nThe set of allowed values 允许的值 *for each***attribute is called the domain of the attribute\n\n\n\n\n\n\n\n\n\nAttribute values are (normally) required to be atomic, that is, indivisible.(不可分割类型)\nMovies ( title:string, year:integer, length:integer, genre:string)\n\n1.1.5.Equivalent Representations of a Relation一个给定的关系中元组的集合：Relation Instances(实例) \n属性、元组都是无序的，可以随便改变顺序但仍然为一个关系模型\nOrder of tuples is irrelevant\n1.1.6.Key\n\n\n\n\n\n\n\n\nA set of attributes forms a key for a relation if we do not allow two tuples in a relation instance to have the same values **in all the **attribute of the key.\n关系中可作键的属性集可能有多个\n1.2.Defining a Relation Schema in SQL\n\n\n\n1.2.1.SQL启动语句以及基本语法\n\n\n\n\n\n\n1.2.2.SQL分类\n1.2.3. Data Types\n\n（mysql 不区分大小写）\n\n\n\n\n\n\n\n\n\nAll attributes must have a data type.\n1.字符串\nCHAR(n)#定长字符串\n\nVARCHAR(n)#变长字符串\n\n其他：\n\n2.位串由01组成\nbit(n)#固定长度\nbit varying(n)#可变长度\n\n3.boolean\nboolean\n#可能的值有\ntrue false unknown\n\n\n4.int&#x2F;interger、浮点型\n\ndouble(2,1)#代表2位数据总长度，小数点在从右往左1的位置，如1.1\n\n\nDates and times\n\n\n\n1.2.4.定义表和表操作\n\nCREATE TABLE Salesman&#x2F;*SQL对⼤⼩写不敏感*&#x2F;\n(empid char(9) PRIMARY KEY,\nidno char(18) UNIQUE,\nname char(8) NOT NULL,\ngender bit NOT NULL,\nphone char(20),\ndeptid int NULL\n);\n\n\n\n\n\n\n\n\n\n\nNote that there is no cognominal(同名的) tables in a DB\n\nModifying Relation Schemas\n\nALTER TABLE ADD column-name datatype NULL；\n增加一列\nALTER TABLE DROP column-name;\n删除一列\nALTER TABLE tablename RENAME TO newname;\n改表名\nDROP TABLE tablename;\n删除表\n\n\nDefault Values\n\nWhen we create or modify tuples, we  sometimes do not  have values for all components.\nSQL provides the NULL value as default value. (隐含默认NULL)\n When we declare an attribute and its data type, we may add the keyword &#x3D;&#x3D;DEFAULT&#x3D;&#x3D; and &#x3D;&#x3D;an appropriate value&#x3D;&#x3D;.\ngender CHAR(1) DEFAULT “？”\n\n\nDeclaring Keys\n\n声明某⼀属性(⾮多属性)为“键”：在属性被列入关系时就声明。\ndeptid  int    PRIMARY KEY,\n\n如果声明一组(一个及以上)属性为键需要:\nPRIMARY KEY (orderno, lineno)\n\n\nPrimary Key and Unique\n\n\n\n\n\n\n\n\n\n\nAtable has and only has one Primary Key, (键只能声明⼀次)，while it may has any number of Unique declarations.\n1、Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求。\n2、一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY。\n1.3.An Algebraic Query Language关系代数的表达式称为查询（query）\nOperands &#x2F;操作数are relations or variables \nOperators &#x2F;操作符号are symbols denoting\n1.3.1.传统关系代数分类\nThe usual set operations: union, intersection and difference (关系：并、交、差)\n\nOperations that remove parts of a relation:\nSelection: eliminates(消除) some rows (tuples)按条件选取行\n\n\n​      Projection(投影): eliminates some colunms (attributes)选列\n\nOperations that combine(组合联接) the tuples of two relations\n\n​       Cartesian  product(笛卡尔积)：将两个关系的所有可能配对形成新关系。\n​       Join(连接):\n​         Natural join ⾃然联接\n​         Theta-join θ联接\n\nRenaming改名:不影响关系中的元组但是改变了关系中的模式\n\n1.3.2.Set Operations on Relations集合操作\n\n\n\n\n\n\n\n\n\n注意集合操作前，需要各个属性相同，否则需要重命名\n1.3.3.Projection 选属性","slug":"Database Note","date":"2022-04-19T15:03:46.000Z","categories_index":"-Mysql","tags_index":"database","author_index":"赫"},{"id":"85b67fe6b30f1568e5071876ed7b54d4","title":"安装Mysql","content":"安装MySQL下载安装包：下载网址：https://dev.mysql.com/downloads/\n\n安装添加环境变量\n\n我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量\n\n选择Path-&gt;编辑-&gt;新建，添加：你的mysql安装文件下的bin文件夹地址\n\n在安装目录下新建my.ini文件（文本文档）\n\n编辑my.ini文件，注意替换你自己电脑上的路径\n\n\n[mysqld]\nbasedir &#x3D; D:\\environment\\mysql-5.7.31\\  &#x2F;&#x2F;把这两行路径改成自己的安装路径\ndatadir &#x3D; D:\\environment\\mysql-5.7.31\\data\\\nport &#x3D; 3306\nskip-grant-tables\n\n\n\n启动cmd(用管理员身份)\nmysqld -install\nmysqld --initialize-insecure --user&#x3D;mysql\n\n这步完成后，在文件夹里会生成一个data文件（如果没有就自己加一个）\n\n\n完成后会显示MySQL 服务已经启动成功\n然后通过命令mysql -u root -p，进入mysql管理界面（密码为空）\nALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;111111&#39;;\n\n输入exit 退出\n","slug":"安装MySQL","date":"2022-04-19T15:03:46.000Z","categories_index":"-Mysql","tags_index":"database","author_index":"赫"}]